<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>netplan</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#general-structure">General structure</a></li>
<li><a href="#device-configuration-ids">Device configuration IDs</a></li>
<li><a href="#common-properties-for-physical-device-types">Common properties for physical device types</a></li>
<li><a href="#common-properties-for-all-device-types">Common properties for all device types</a></li>
<li><a href="#routing">Routing</a></li>
<li><a href="#properties-for-device-type-ethernets">Properties for device type <code>ethernets:</code></a></li>
<li><a href="#properties-for-device-type-wifis">Properties for device type <code>wifis:</code></a></li>
<li><a href="#properties-for-device-type-bridges">Properties for device type <code>bridges:</code></a></li>
<li><a href="#properties-for-device-type-bonds">Properties for device type <code>bonds:</code></a></li>
<li><a href="#properties-for-device-type-vlans">Properties for device type <code>vlans:</code></a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</nav>
<h2 id="introduction">Introduction</h2>
<p>Distribution installers, cloud instantiation, image builds for particular devices, or any other way to deploy an operating system put its desired network configuration into YAML configuration file(s). During early boot, the netplan “network renderer” runs which reads <code>/{lib,etc,run}/netplan/*.yaml</code> and writes configuration to <code>/run</code> to hand off control of devices to the specified networking daemon.</p>
<ul>
<li>Configured devices get handled by systemd-networkd by default, unless explicitly marked as managed by a specific renderer (NetworkManager)</li>
<li>Devices not covered by the network config do not get touched at all.</li>
<li>Usable in initramfs (few dependencies and fast)</li>
<li>No persistent generated config, only original YAML config</li>
<li>Parser supports multiple config files to allow applications like libvirt or lxd to package up expected network config (<code>virbr0</code>, <code>lxdbr0</code>), or to change the global default policy to use NetworkManager for everything.</li>
<li>Retains the flexibility to change backends/policy later or adjust to removing NetworkManager, as generated configuration is ephemeral.</li>
</ul>
<h2 id="general-structure">General structure</h2>
<p>netplan’s configuration files use the <a href="http://yaml.org/spec/1.1/current.html">YAML</a> format. All <code>/{lib,etc,run}/netplan/*.yaml</code> are considered. Lexicographically later files (regardless of in which directory they are) amend (new mapping keys) or override (same mapping keys) previous ones. A file in <code>/run/netplan</code> completely shadows a file with same name in <code>/etc/netplan</code>, and a file in either of those directories shadows a file with the same name in <code>/lib/netplan</code>.</p>
<p>The top-level node in a netplan configuration file is a <code>network:</code> mapping that contains <code>version: 2</code> (the YAML currently being used by curtin, MaaS, etc. is version 1), and then device definitions grouped by their type, such as <code>ethernets:</code>, <code>wifis:</code>, or <code>bridges:</code>. These are the types that our renderer can understand and are supported by our backends.</p>
<p>Each type block contains device definitions as a map where the keys (called “configuration IDs”) are defined as below.</p>
<h2 id="device-configuration-ids">Device configuration IDs</h2>
<p>The key names below the per-device-type definition maps (like <code>ethernets:</code>) are called “ID”s. They must be unique throughout the entire set of configuration files. Their primary purpose is to serve as anchor names for composite devices, for example to enumerate the members of a bridge that is currently being defined.</p>
<p>There are two physically/structurally different classes of device definitions, and the ID field has a different interpretation for each:</p>
<dl>
<dt>Physical devices</dt>
<dd><p>(Examples: ethernet, wifi) These can dynamically come and go between reboots and even during runtime (hotplugging). In the generic case, they can be selected by <code>match:</code> rules on desired properties, such as name/name pattern, MAC address, driver, or device paths. In general these will match any number of devices (unless they refer to properties which are unique such as the full path or MAC address), so without further knowledge about the hardware these will always be considered as a group.</p>
<p>It is valid to specify no match rules at all, in which case the ID field is simply the interface name to be matched. This is mostly useful if you want to keep simple cases simple, and it’s how network device configuration has been done for a long time.</p>
<p>If there are <code>match</code>: rules, then the ID field is a purely opaque name which is only being used for references from definitions of compound devices in the config.</p>
</dd>
<dt>Virtual devices</dt>
<dd><p>(Examples: veth, bridge, bond) These are fully under the control of the config file(s) and the network stack. I. e. these devices are being created instead of matched. Thus <code>match:</code> and <code>set-name:</code> are not applicable for these, and the ID field is the name of the created virtual device.</p>
</dd>
</dl>
<h2 id="common-properties-for-physical-device-types">Common properties for physical device types</h2>
<dl>
<dt><code>match</code> (mapping)</dt>
<dd><p>This selects a subset of available physical devices by various hardware properties. The following configuration will then apply to all matching devices, as soon as they appear. <em>All</em> specified properties must match.</p>
<dl>
<dt><code>name</code> (scalar)</dt>
<dd>Current interface name. Globs are supported, and the primary use case for matching on names, as selecting one fixed name can be more easily achieved with having no <code>match:</code> at all and just using the ID (see above). Note that currently only networkd supports globbing, NetworkManager does not.
</dd>
<dt><code>macaddress</code> (scalar)</dt>
<dd>Device’s MAC address in the form “XX:XX:XX:XX:XX:XX”. Globs are not allowed.
</dd>
<dt><code>driver</code> (scalar)</dt>
<dd>Kernel driver name, corresponding to the <code>DRIVER</code> udev property. Globs are supported. Matching on driver is <em>only</em> supported with networkd.
</dd>
</dl>
<p>Examples:</p>
<ul>
<li><p>all cards on second PCI bus:</p>
<pre><code> match:
   name: enp2*</code></pre></li>
<li><p>fixed MAC address:</p>
<pre><code> match:
   macaddress: 11:22:33:AA:BB:FF</code></pre></li>
<li><p>first card of driver <code>ixgbe</code>:</p>
<pre><code> match:
   driver: ixgbe
   name: en*s0</code></pre></li>
</ul>
</dd>
<dt><code>set-name</code> (scalar)</dt>
<dd><p>When matching on unique properties such as path or MAC, or with additional assumptions such as “there will only ever be one wifi device”, match rules can be written so that they only match one device. Then this property can be used to give that device a more specific/desirable/nicer name than the default from udev’s ifnames. Any additional device that satisfies the match rules will then fail to get renamed and keep the original kernel name (and dmesg will show an error).</p>
</dd>
<dt><code>wakeonlan</code> (bool)</dt>
<dd><p>Enable wake on LAN. Off by default.</p>
</dd>
</dl>
<h2 id="common-properties-for-all-device-types">Common properties for all device types</h2>
<dl>
<dt><code>renderer</code> (scalar)</dt>
<dd><p>Use the given networking backend for this definition. Currently supported are <code>networkd</code> and <code>NetworkManager</code>. This property can be specified globally in <code>networks:</code>, for a device type (in e. g. <code>ethernets:</code>) or for a particular device definition. Default is <code>networkd</code>.</p>
</dd>
<dt><code>dhcp4</code> (bool)</dt>
<dd><p>Enable DHCP for IPv4. Off by default.</p>
</dd>
<dt><code>dhcp6</code> (bool)</dt>
<dd><p>Enable DHCP for IPv6. Off by default. This covers both stateless DHCP - where the DHCP server supplies information like DNS nameservers but not the IP address - and stateful DHCP, where the server provides both the address and the other information.</p>
<p>If you are in an IPv6-only environment with completely stateless autoconfiguration (SLAAC with RDNSS), this option can be set to cause the interface to be brought up. (Setting accept-ra alone is not sufficient.) Autoconfiguration will still honour the contents of the router advertisement and only use DHCP if requested in the RA.</p>
<p>Note that <strong><code>rdnssd</code></strong>(8) is required to use RDNSS with networkd. No extra software is required for NetworkManager.</p>
</dd>
<dt><code>link-local</code> (sequence of scalars)</dt>
<dd><p>Configure the link-local addresses to bring up. Valid options are ‘ipv4’ and ‘ipv6’, which respectively allow enabling IPv4 and IPv6 link local addressing. If this field is not defined, the default is to enable only IPv6 link-local addresses. If the field is defined but configured as an empty set, IPv6 link-local addresses are disabled as well as IPv4 link- local addresses.</p>
<p>This feature enables or disables link-local addresses for a protocol, but the actual implementation differs per backend. On networkd, this directly changes the behavior and may add an extra address on an interface. When using the NetworkManager backend, enabling link-local has no effect if the interface also has DHCP enabled.</p>
<p>Example to enable only IPv4 link-local: <code>link-local: [ ipv4 ]</code> Example to enable all link-local addresses: <code>link-local: [ ipv4, ipv6 ]</code> Example to disable all link-local addresses: <code>link-local: [ ]</code></p>
</dd>
<dt><code>critical</code> (bool)</dt>
<dd><p>(networkd backend only) Designate the connection as “critical to the system”, meaning that special care will be taken by systemd-networkd to not release the IP from DHCP when it the daemon is restarted.</p>
</dd>
<dt><code>dhcp-identifier</code> (scalar)</dt>
<dd><p>When set to ‘mac’; pass that setting over to systemd-networkd to use the device’s MAC address as a unique identifier rather than a RFC4361-compliant Client ID. This has no effect when NetworkManager is used as a renderer.</p>
</dd>
<dt><code>accept-ra</code> (bool)</dt>
<dd><p>Accept Router Advertisement that would have the kernel configure IPv6 by itself. When enabled, accept Router Advertisements. When disabled, do not respond to Router Advertisements. If unset use the host kernel default setting.</p>
</dd>
<dt><code>addresses</code> (sequence of scalars)</dt>
<dd><p>Add static addresses to the interface in addition to the ones received through DHCP or RA. Each sequence entry is in CIDR notation, i. e. of the form <code>addr/prefixlen</code>. <code>addr</code> is an IPv4 or IPv6 address as recognized by <strong><code>inet_pton</code></strong>(3) and <code>prefixlen</code> the number of bits of the subnet.</p>
<p>For virtual devices (bridges, bonds, vlan) if there is no address configured and DHCP is disabled, the interface may still be brought online, but will not be addressable from the network.</p>
<p>Example: <code>addresses: [192.168.14.2/24, &quot;2001:1::1/64&quot;]</code></p>
</dd>
<dt><code>gateway4</code>, <code>gateway6</code> (scalar)</dt>
<dd><p>Set default gateway for IPv4/6, for manual address configuration. This requires setting <code>addresses</code> too. Gateway IPs must be in a form recognized by <strong><code>inet_pton</code></strong>(3).</p>
<p>Example for IPv4: <code>gateway4: 172.16.0.1</code> Example for IPv6: <code>gateway6: &quot;2001:4::1&quot;</code></p>
</dd>
<dt><code>nameservers</code> (mapping)</dt>
<dd><p>Set DNS servers and search domains, for manual address configuration. There are two supported fields: <code>addresses:</code> is a list of IPv4 or IPv6 addresses similar to <code>gateway*</code>, and <code>search:</code> is a list of search domains.</p>
<p>Example:</p>
<pre><code>ethernets:
  id0:
    [...]
    nameservers:
      search: [lab, home]
      addresses: [8.8.8.8, &quot;FEDC::1&quot;]</code></pre>
</dd>
<dt><code>macaddress</code> (scalar)</dt>
<dd><p>Set the device’s MAC address. The MAC address must be in the form “XX:XX:XX:XX:XX:XX”.</p>
<p>Example:</p>
<pre><code>ethernets:
  id0:
    [...]
    macaddress: 52:54:00:6b:3c:59</code></pre>
</dd>
<dt><code>mtu</code> (scalar)</dt>
<dd><p>Set the Maximum Transmission Unit for the interface. The default is 1500. Valid values depend on your network interface.</p>
<p><strong>Note:</strong> This will not work reliably for devices matched by name only, due to interactions with device renaming in udev. Match devices by MAC when setting MTU.</p>
</dd>
<dt><code>optional</code> (bool)</dt>
<dd><p>An optional device is not required for booting. Normally, networkd will wait some time for device to become configured before proceeding with booting. However, if a device is marked as optional, networkd will not wait for it. This is <em>only</em> supported by networkd, and the default is false.</p>
<p>Example:</p>
<pre><code>ethernets:
  eth7:
    # this is plugged into a test network that is often
    # down - don&#39;t wait for it to come up during boot.
    dhcp4: true
    optional: true</code></pre>
</dd>
<dt><code>optional-addresses</code> (sequence of scalars)</dt>
<dd><p>Specify types of addresses that are not required for a device to be considered online. This changes the behavior of backends at boot time to avoid waiting for addresses that are marked optional, and thus consider the interface as “usable” sooner. This does not disable these addresses, which will be brought up anyway.</p>
<p>Example:</p>
<pre><code>ethernets:
  eth7:
    dhcp4: true
    dhcp6: true
    optional-addresses: [ ipv4-ll, dhcp6 ]</code></pre>
</dd>
<dt><code>routes</code> (mapping)</dt>
<dd><p>Configure static routing for the device; see the <code>Routing</code> section below.</p>
</dd>
<dt><code>routing-policy</code> (mapping)</dt>
<dd><p>Configure policy routing for the device; see the <code>Routing</code> section below.</p>
</dd>
</dl>
<h2 id="routing">Routing</h2>
<p>Complex routing is possible with netplan. Standard static routes as well as policy routing using routing tables are supported via the <code>networkd</code> backend.</p>
<p>These options are available for all types of interfaces.</p>
<dl>
<dt><code>routes</code> (mapping)</dt>
<dd><p>The <code>routes</code> block defines standard static routes for an interface. At least <code>to</code> and <code>via</code> must be specified.</p>
<p>For <code>from</code>, <code>to</code>, and <code>via</code>, both IPv4 and IPv6 addresses are recognized, and must be in the form <code>addr/prefixlen</code> or <code>addr</code>.</p>
<dl>
<dt><code>from</code> (scalar)</dt>
<dd>Set a source IP address for traffic going through the route.
</dd>
<dt><code>to</code> (scalar)</dt>
<dd>Destination address for the route.
</dd>
<dt><code>via</code> (scalar)</dt>
<dd>Address to the gateway to use for this route.
</dd>
<dt><code>on-link</code> (bool)</dt>
<dd>When set to “true”, specifies that the route is directly connected to the interface.
</dd>
<dt><code>metric</code> (scalar)</dt>
<dd>The relative priority of the route. Must be a positive integer value.
</dd>
<dt><code>type</code> (scalar)</dt>
<dd>The type of route. Valid options are “unicast” (default), “unreachable”, “blackhole” or “prohibit”.
</dd>
<dt><code>scope</code> (scalar)</dt>
<dd>The route scope, how wide-ranging it is to the network. Possible values are “global”, “link”, or “host”.
</dd>
<dt><code>table</code> (scalar)</dt>
<dd>The table number to use for the route. In some scenarios, it may be useful to set routes in a separate routing table. It may also be used to refer to routing policy rules which also accept a <code>table</code> parameter. Allowed values are positive integers starting from 1. Some values are already in use to refer to specific routing tables: see <code>/etc/iproute2/rt_tables</code>.
</dd>
</dl>
</dd>
<dt><code>routing-policy</code> (mapping)</dt>
<dd><p>The <code>routing-policy</code> block defines extra routing policy for a network, where traffic may be handled specially based on the source IP, firewall marking, etc.</p>
<p>For <code>from</code>, <code>to</code>, both IPv4 and IPv6 addresses are recognized, and must be in the form <code>addr/prefixlen</code> or <code>addr</code>.</p>
<dl>
<dt><code>from</code> (scalar)</dt>
<dd>Set a source IP address to match traffic for this policy rule.
</dd>
<dt><code>to</code> (scalar)</dt>
<dd>Match on traffic going to the specified destination.
</dd>
<dt><code>table</code> (scalar)</dt>
<dd>The table number to match for the route. In some scenarios, it may be useful to set routes in a separate routing table. It may also be used to refer to routes which also accept a <code>table</code> parameter. Allowed values are positive integers starting from 1. Some values are already in use to refer to specific routing tables: see <code>/etc/iproute2/rt_tables</code>.
</dd>
<dt><code>priority</code> (scalar)</dt>
<dd>Specify a priority for the routing policy rule, to influence the order in which routing rules are processed. A higher number means lower priority: rules are processed in order by increasing priority number.
</dd>
<dt><code>mark</code> (scalar)</dt>
<dd>Have this routing policy rule match on traffic that has been marked by the iptables firewall with this value. Allowed values are positive integers starting from 1.
</dd>
<dt><code>type-of-service</code> (scalar)</dt>
<dd>Match this policy rule based on the type of service number applied to the traffic.
</dd>
</dl>
</dd>
</dl>
<h2 id="properties-for-device-type-ethernets">Properties for device type <code>ethernets:</code></h2>
<p>Ethernet device definitions do not support any specific properties beyond the common ones described above.</p>
<h2 id="properties-for-device-type-wifis">Properties for device type <code>wifis:</code></h2>
<p>Note that <code>systemd-networkd</code> does not natively support wifi, so you need wpasupplicant installed if you let the <code>networkd</code> renderer handle wifi.</p>
<dl>
<dt><code>access-points</code> (mapping)</dt>
<dd><p>This provides pre-configured connections to NetworkManager. Note that users can of course select other access points/SSIDs. The keys of the mapping are the SSIDs, and the values are mappings with the following supported properties:</p>
<dl>
<dt><code>password</code> (scalar)</dt>
<dd>Enable WPA2 authentication and set the passphrase for it. If not given, the network is assumed to be open. Other authentication modes are not currently supported.
</dd>
<dt><code>mode</code> (scalar)</dt>
<dd>Possible access point modes are <code>infrastructure</code> (the default), <code>ap</code> (create an access point to which other devices can connect), and <code>adhoc</code> (peer to peer networks without a central access point). <code>ap</code> is only supported with NetworkManager.
</dd>
</dl>
</dd>
</dl>
<h2 id="properties-for-device-type-bridges">Properties for device type <code>bridges:</code></h2>
<dl>
<dt><code>interfaces</code> (sequence of scalars)</dt>
<dd><p>All devices matching this ID list will be added to the bridge. This may be an empty list, in which case the bridge will be brought online with no member interfaces.</p>
<p>Example:</p>
<pre><code>  ethernets:
    switchports:
      match: {name: &quot;enp2*&quot;}
  [...]
  bridges:
    br0:
      interfaces: [switchports]</code></pre>
</dd>
<dt><code>parameters</code> (mapping)</dt>
<dd><p>Customization parameters for special bridging options. Unless otherwise specified, parameter values for time intervals should be expressed in milliseconds, but can also be expressed in seconds using a time suffix (such as “s” for seconds, “ms” for milliseconds).</p>
<dl>
<dt><code>ageing-time</code> (scalar)</dt>
<dd>Set the period of time (in seconds) to keep a MAC address in the forwarding database after a packet is received. This maps to the AgeingTimeSec= property when the networkd renderer is used.
</dd>
<dt><code>priority</code> (scalar)</dt>
<dd>Set the priority value for the bridge. This value should be a number between <code>0</code> and <code>65535</code>. Lower values mean higher priority. The bridge with the higher priority will be elected as the root bridge.
</dd>
<dt><code>port-priority</code> (scalar)</dt>
<dd>Set the port priority to <priority>. The priority value is a number between <code>0</code> and <code>63</code>. This metric is used in the designated port and root port selection algorithms.
</dd>
<dt><code>forward-delay</code> (scalar)</dt>
<dd>Specify the period of time (in seconds) the bridge will remain in Listening and Learning states before getting to the Forwarding state. This field maps to the ForwardDelaySec= property for the networkd renderer.
</dd>
<dt><code>hello-time</code> (scalar)</dt>
<dd>Specify the interval (in seconds) between two hello packets being sent out from the root and designated bridges. Hello packets communicate information about the network topology. When the networkd renderer is used, this maps to the HelloTimeSec= property.
</dd>
<dt><code>max-age</code> (scalar)</dt>
<dd>Set the maximum age (in seconds) of a hello packet. If the last hello packet is older than that value, the bridge will attempt to become the root bridge. This maps to the MaxAgeSec= property when the networkd renderer is used.
</dd>
<dt><code>path-cost</code> (scalar)</dt>
<dd>Set the cost of a path on the bridge. Faster interfaces should have a lower cost. This allows a finer control on the network topology so that the fastest paths are available whenever possible.
</dd>
<dt><code>stp</code> (bool)</dt>
<dd>Define whether the bridge should use Spanning Tree Protocol. The default value is “true”, which means that Spanning Tree should be used.
</dd>
</dl>
</dd>
</dl>
<h2 id="properties-for-device-type-bonds">Properties for device type <code>bonds:</code></h2>
<dl>
<dt><code>interfaces</code> (sequence of scalars)</dt>
<dd><p>All devices matching this ID list will be added to the bond.</p>
<p>Example:</p>
<pre><code>  ethernets:
    switchports:
      match: {name: &quot;enp2*&quot;}
  [...]
  bonds:
    bond0:
      interfaces: [switchports]</code></pre>
</dd>
<dt><code>parameters</code> (mapping)</dt>
<dd><p>Customization parameters for special bonding options. Unless otherwise specified, parameter values for time intervals should be expressed in milliseconds, but can also be expressed in seconds using a time suffix (such as “s” for seconds, “ms” for milliseconds).</p>
<dl>
<dt><code>mode</code> (scalar)</dt>
<dd>Set the bonding mode used for the interfaces. The default is <code>balance-rr</code> (round robin). Possible values are <code>balance-rr</code>, <code>active-backup</code>, <code>balance-xor</code>, <code>broadcast</code>, <code>802.3ad</code>, <code>balance-tlb</code>, and <code>balance-alb</code>.
</dd>
<dt><code>lacp-rate</code> (scalar)</dt>
<dd>Set the rate at which LACPDUs are transmitted. This is only useful in 802.3ad mode. Possible values are <code>slow</code> (30 seconds, default), and <code>fast</code> (every second).
</dd>
<dt><code>mii-monitor-interval</code> (scalar)</dt>
<dd>Specifies the interval for MII monitoring (verifying if an interface of the bond has carrier). The default is <code>0</code>; which disables MII monitoring. This is equivalent to the MIIMonitorSec= field for the networkd backend.
</dd>
<dt><code>min-links</code> (scalar)</dt>
<dd>The minimum number of links up in a bond to consider the bond interface to be up.
</dd>
<dt><code>transmit-hash-policy</code> (scalar)</dt>
<dd>Specifies the transmit hash policy for the selection of slaves. This is only useful in balance-xor, 802.3ad and balance-tlb modes. Possible values are <code>layer2</code>, <code>layer3+4</code>, <code>layer2+3</code>, <code>encap2+3</code>, and <code>encap3+4</code>.
</dd>
<dt><code>ad-select</code> (scalar)</dt>
<dd>Set the aggregation selection mode. Possible values are <code>stable</code>, <code>bandwidth</code>, and <code>count</code>. This option is only used in 802.3ad mode.
</dd>
<dt><code>all-slaves-active</code> (bool)</dt>
<dd>If the bond should drop duplicate frames received on inactive ports, set this option to <code>false</code>. If they should be delivered, set this option to <code>true</code>. The default value is false, and is the desirable behavior in most situations.
</dd>
<dt><code>arp-interval</code> (scalar)</dt>
<dd>Set the interval value for how frequently ARP link monitoring should happen. The default value is <code>0</code>, which disables ARP monitoring. For the networkd backend, this maps to the ARPIntervalSec= property.
</dd>
<dt><code>arp-ip-targets</code> (sequence of scalars)</dt>
<dd>IPs of other hosts on the link which should be sent ARP requests in order to validate that a slave is up. This option is only used when <code>arp-interval</code> is set to a value other than <code>0</code>. At least one IP address must be given for ARP link monitoring to function. Only IPv4 addresses are supported. You can specify up to 16 IP addresses. The default value is an empty list.
</dd>
<dt><code>arp-validate</code> (scalar)</dt>
<dd>Configure how ARP replies are to be validated when using ARP link monitoring. Possible values are <code>none</code>, <code>active</code>, <code>backup</code>, and <code>all</code>.
</dd>
<dt><code>arp-all-targets</code> (scalar)</dt>
<dd>Specify whether to use any ARP IP target being up as sufficient for a slave to be considered up; or if all the targets must be up. This is only used for <code>active-backup</code> mode when <code>arp-validate</code> is enabled. Possible values are <code>any</code> and <code>all</code>.
</dd>
<dt><code>up-delay</code> (scalar)</dt>
<dd>Specify the delay before enabling a link once the link is physically up. The default value is <code>0</code>. This maps to the UpDelaySec= property for the networkd renderer.
</dd>
<dt><code>down-delay</code> (scalar)</dt>
<dd>Specify the delay before disabling a link once the link has been lost. The default value is <code>0</code>. This maps to the DownDelaySec= property for the networkd renderer.
</dd>
<dt><code>fail-over-mac-policy</code> (scalar)</dt>
<dd>Set whether to set all slaves to the same MAC address when adding them to the bond, or how else the system should handle MAC addresses. The possible values are <code>none</code>, <code>active</code>, and <code>follow</code>.
</dd>
<dt><code>gratuitous-arp</code> (scalar)</dt>
<dd><p>Specify how many ARP packets to send after failover. Once a link is up on a new slave, a notification is sent and possibly repeated if this value is set to a number greater than <code>1</code>. The default value is <code>1</code> and valid values are between <code>1</code> and <code>255</code>. This only affects <code>active-backup</code> mode.</p>
<p>For historical reasons, the misspelling <code>gratuitious-arp</code> is also accepted and has the same function.</p>
</dd>
<dt><code>packets-per-slave</code> (scalar)</dt>
<dd>In <code>balance-rr</code> mode, specifies the number of packets to transmit on a slave before switching to the next. When this value is set to <code>0</code>, slaves are chosen at random. Allowable values are between <code>0</code> and <code>65535</code>. The default value is <code>1</code>. This setting is only used in <code>balance-rr</code> mode.
</dd>
<dt><code>primary-reselect-policy</code> (scalar)</dt>
<dd>Set the reselection policy for the primary slave. On failure of the active slave, the system will use this policy to decide how the new active slave will be chosen and how recovery will be handled. The possible values are <code>always</code>, <code>better</code>, and <code>failure</code>.
</dd>
<dt><code>resend-igmp</code> (scalar)</dt>
<dd><p>In modes <code>balance-rr</code>, <code>active-backup</code>, <code>balance-tlb</code> and <code>balance-alb</code>, a failover can switch IGMP traffic from one slave to another.</p>
<p>This parameter specifies how many IGMP membership reports are issued on a failover event. Values range from 0 to 255. 0 disables sending membership reports. Otherwise, the first membership report is sent on failover and subsequent reports are sent at 200ms intervals.</p>
</dd>
<dt><code>learn-packet-interval</code> (scalar)</dt>
<dd>Specify the interval (seconds) between sending learning packets to each slave. The value range is between <code>1</code> and <code>0x7fffffff</code>. The default value is <code>1</code>. This option only affects <code>balance-tlb</code> and <code>balance-alb</code> modes. Using the networkd renderer, this field maps to the LearnPacketIntervalSec= property.
</dd>
<dt><code>primary</code> (scalar)</dt>
<dd>Specify a device to be used as a primary slave, or preferred device to use as a slave for the bond (ie. the preferred device to send data through), whenever it is available. This only affects <code>active-backup</code>, <code>balance-alb</code>, and <code>balance-tlb</code> modes.
</dd>
</dl>
</dd>
</dl>
<h2 id="properties-for-device-type-vlans">Properties for device type <code>vlans:</code></h2>
<dl>
<dt><code>id</code> (scalar)</dt>
<dd><p>VLAN ID, a number between 0 and 4094.</p>
</dd>
<dt><code>link</code> (scalar)</dt>
<dd><p>netplan ID of the underlying device definition on which this VLAN gets created.</p>
</dd>
</dl>
<p>Example:</p>
<pre><code>ethernets:
  eno1: {...}
vlans:
  en-intra:
    id: 1
    link: eno1
    dhcp4: yes
  en-vpn:
    id: 2
    link: eno1
    address: ...</code></pre>
<h2 id="examples">Examples</h2>
<p>Configure an ethernet device with networkd, identified by its name, and enable DHCP:</p>
<pre><code>network:
  version: 2
  ethernets:
    eno1:
      dhcp4: true
      </code></pre>
<p>This is an example of a static-configured interface with multiple IPv4 addresses and multiple gateways with networkd, with equal route metric levels, and static DNS nameservers (Google DNS for this example):</p>
<pre><code>network:
  version: 2
  renderer: networkd
  ethernets:
    eno1:
      addresses:
      - 10.0.0.10/24
      - 11.0.0.11/24
      nameservers:
        addresses:
          - 8.8.8.8
          - 8.8.4.4
      routes:
      - to: 0.0.0.0/0
        via: 10.0.0.1
        metric: 100
      - to: 0.0.0.0/0
        via: 11.0.0.1
        metric: 100 </code></pre>
<p>This is a complex example which shows most available features:</p>
<pre><code>network:
  version: 2
  # if specified, can only realistically have that value, as networkd cannot
  # render wifi/3G.
  renderer: NetworkManager
  ethernets:
    # opaque ID for physical interfaces, only referred to by other stanzas
    id0:
      match:
        macaddress: 00:11:22:33:44:55
      wakeonlan: true
      dhcp4: true
      addresses:
        - 192.168.14.2/24
        - 192.168.14.3/24
        - &quot;2001:1::1/64&quot;
      gateway4: 192.168.14.1
      gateway6: &quot;2001:1::2&quot;
      nameservers:
        search: [foo.local, bar.local]
        addresses: [8.8.8.8]
      routes:
        - to: 0.0.0.0/0
          via: 11.0.0.1
          table: 70
          on-link: true
          metric: 3
      routing-policy:
        - to: 10.0.0.0/8
          from: 192.168.14.2/24
          table: 70
          priority: 100
        - to: 20.0.0.0/8
          from: 192.168.14.3/24
          table: 70
          priority: 50
    lom:
      match:
        driver: ixgbe
      # you are responsible for setting tight enough match rules
      # that only match one device if you use set-name
      set-name: lom1
      dhcp6: true
    switchports:
      # all cards on second PCI bus unconfigured by
      # themselves, will be added to br0 below
      # note: globbing is not supported by NetworkManager
      match:
        name: enp2*
      mtu: 1280
  wifis:
    all-wlans:
      # useful on a system where you know there is
      # only ever going to be one device
      match: {}
      access-points:
        &quot;Joe&#39;s home&quot;:
          # mode defaults to &quot;infrastructure&quot; (client)
          password: &quot;s3kr1t&quot;
    # this creates an AP on wlp1s0 using hostapd
    # no match rules, thus the ID is the interface name
    wlp1s0:
      access-points:
        &quot;guest&quot;:
           mode: ap
           # no WPA config implies default of open
  bridges:
    # the key name is the name for virtual (created) interfaces
    # no match: and set-name: allowed
    br0:
      # IDs of the components; switchports expands into multiple interfaces
      interfaces: [wlp1s0, switchports]
      dhcp4: true</code></pre>
<!--- vim: ft=markdown
-->
</body>
</html>
